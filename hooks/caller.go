package hooks

import (
	"fmt"
	"runtime"
	"strings"
)

// Recursively query the caller until it finds the first call generated by a non-logrus package.
// The filename of all logrus package calls is logrus/...
// So by excluding filenames starting with logrus, you can exclude all the logrus package's own function calls
func FindCaller(skip int) string {
	file := ""
	line := 0
	for i := 0; i < 10; i++ {
		file, line = getCaller(skip + i)
		if !strings.HasPrefix(file, "logrus") {
			break
		}
	}
	return fmt.Sprintf("%s:%d", file, line)
}

// Here you can actually get the name of the function: fnName := runtime.FuncForPC(pc).Name()
// The file name and line number are enough to locate the problem,  Therefore the first value returned by the caller is ignored:pc
// In the standard library log we can choose to log the full path of the file or the file name, but it is most appropriate to use the process concurrently,
// Because the full path to a file is often long, and the file name is often duplicated in multiple packages, we choose to take one more level, to the level of the upper directory where the file is located.
func getCaller(skip int) (string, int) {
	_, file, line, ok := runtime.Caller(skip)
	// fnName := runtime.FuncForPC(pc).Name()
	// fmt.Println(file)
	// fmt.Println(line)
	if !ok {
		return "", 0
	}
	n := 0
	for i := len(file) - 1; i > 0; i-- {
		if file[i] == '/' {
			n++
			if n >= 2 {
				file = file[i+1:]
				break
			}
		}
	}
	return file, line
}
